# (PART) EXPLOITING DYNAMICS {-}

# Constructing Evolution Features to Capture Change over Time {#evo}

```{r 06-setup, eval = FALSE, echo = FALSE, cache = TRUE, message = FALSE, results='asis'}
source("code/00-chapter-start-bib.R")
print_bib("Niemann:CBMS2015", bib = bib)
```

:::: {.infobox .chapter-summary data-latex="{tasks.pdf}"}

#### Brief Chapter Summary {-}

We propose a framework to extract "evolution features" from timestamped medical data, which describe the study participants' change over time. 
We show that exploiting these novel features improves classification performance by validating our workflow on the SHIP data for the target variable hepatic steatosis.

::::

:::: {.lit .chapter-literature data-latex=""}
This chapter is partly based on:

Uli Niemann, Tommy Hielscher, Myra Spiliopoulou, Henry Völzke, and Jens-Peter Kühn. "Can we classify the participants of a longitudinal epidemiological study from their previous evolution?". In: _Computer-Based Medical Systems (CBMS)_. 2015, pp. 121-126. DOI: [10.1109/CBMS.2015.12](https://doi.org/10.1109%2FCBMS.2015.12).

::::

<!-- **TODO: Einleitende Worte in jedem Kapitel** -->
<!-- https://www.enzyklopaedie-der-wirtschaftsinformatik.de/wi-enzyklopaedie/lexikon/informationssysteme/Sektorspezifische-Anwendungssysteme/Gesundheitswesen--Anwendungssysteme-im/digital-health/digital-health -->

Medical studies with a longitudinal design collect participant data from questionnaires, medical examinations, laboratory analyses, and imaging repeatedly over time [@Voelzke:SHIP11; @who1988world; @holle2005kora].
Hidden temporal information could be made explicit by constructing features that describe the subjects' change over time. 
However, there is a lack of applicable methods for timestamped data with a tiny (\< 5) number of moments. 
We present a framework addressing this shortcoming and demonstrate that augmenting the feature space with so-called _evolution features_ increases classification performance and yields understandable descriptors of change worthy of further investigation. 

Section&nbsp;\@ref(evo-intro) describes work related to the construction of temporal representations in medical data. 
Section&nbsp;\@ref(evo-problem-formulation) introduces the notation and problem formulation.
Section&nbsp;\@ref(evo-concept) presents our evolution feature framework, including a full workflow that encompasses steps to extract evolution features, dealing with class imbalance, and feature selection. 
Section&nbsp;\@ref(evo-evaluation) describe the evaluation setup. 
We report on our results in Section&nbsp;\@ref(evo-results) and present evolution features found to be important for class separation in Section&nbsp;\@ref(evo-important-features). 
We conclude this chapter in Section&nbsp;\@ref(evo-conclusion).

<!-- Ch7 extends Ch3 and Ch4 by considering subpopulation-discovery in the temporal context -->

<!-- %The authors of [@NiemannEtal:ESWA14] propose a workflow for generating classification rules and decision trees to learn the outcome of hepatic steatosis. For this challenge they use data from the Study of Health in Pomerania (SHIP) [@Voelzke:SHIP11]. In this paper, we use a superset of this study data and aim to improve classification quality by additionally extracting features from the evolution of the study participants. Leveraging temporal information from time series is extensively studied in literature. -->
<!-- %In [@KremplEtAl:PKDD11], the authors model the evolution of individuals in a stream-mining environment under concept drift. They identify groups of similar evolving individuals on the basis of multivariate measurements obtained at irregular time-intervals. They use online-trajectory-clustering, assuming that measurements are generated by a Gaussian mixture model. In comparison to our approach, they work within a true stream environment with access to a higher number of measurements for individuals, whereas in an epidemiological data environment the number of measurements is too small across large time-frames and is therefore not suitable for this kind of learning. -->

## Motivation and Comparison to Related Work {#evo-intro}

<!-- **Myra: Literature is a bit old. Look at the work of Panos on temporal representations for health data and add. His work is for conventional ts, not for such short sequcences, so the text after the however still fits** -->

<!-- **Gramarly new sections** -->

<!-- %Medical Mining supports personalized clinical decision making by discovering hidden knowledge from accumulated medical data. -->
Epidemiological studies serve as a basis for the identification of risk factors associated with a medical condition [@guo2020diabetes; @boehme2017stroke; @oliver2020causes]. 
Machine learning is still relatively little used in epidemiology, mainly due to the hypothesis-driven nature of their research. 
However, examples of machine learning applications are the identification of health failure subtypes [@austin2013using] and the discovery of factors (including biomarkers) that modulate a medical outcome [@Raju2014; @valavanis2013derivation]. 
In longitudinal cohort studies, measurements are performed in multiple study waves; hence researchers obtain access to sequences of recordings. 
In the context of machine learning, extracting and leveraging the inherent temporal information from these sequences may increase model performance and, thus, the understanding of the medical condition of interest. 

From a technical point of view, classification problems on timestamped data can be very different.
They can be broadly summarized into three categories:

a. Each instance (patient, study participant) has a label at each time point $t$. The goal is to assign the instance's label at $t$ + 1. Typically, this is a _data stream classification_ problem [@unnikrishnan2020entity; @aggarwal2014survey]. 
b. Each instance is associated with only one label for the all time points. Typically, this is a _timeseries classification_ problem [@fawaz2019deep; @hyndman2018forecasting]. 
c. There are no labels but the time point of an _event_ is to be predicted. This problem is concerned with _event prediction_ [@zhao2019learning; @bagattini2019classification; @beunza2019comparison]. 

Our classification problem falls under (a), but we cannot use the advances of stream classification because we our data is unlabeled except for the last time point and our stream of three time points is tiny. 

In clinical applications, temporal information is often exploited, predominantly for the analysis of patient records. 
For example, Pechenizkiy et al. [@PechenizkiyEtAl:CBMS10] analyzed streams of recordings to predict rehospitalization because of heart failure events during remote patient management. 
Sun et al. [@SunEtAl:ICDM10] computed the similarity between streams of patients from patient monitoring data. 
Combi et al. [@CombiEtAl:2010] reported on streams of life signals, particularly on the temporal analysis of the timestamped medical records of hospital patients.

However, participants of an epidemiological, population-based study are not hospital patients -- they are a random sample of the studied population, often with a skewed class distribution.
In a _longitudinal_ study of this kind, recordings for the same cohort member are made at each moment.
Hielscher et al. [@HielscherEtAl:IDA14] presented a feature engineering approach to extract temporal information from multiple but few patient recordings in a longitudinal epidemiological study. 
First, for each assessment, clusters of feature-value sequences associated with the target variable are found. 
Afterward, original and sequence features are used in conjunction for classification.
Hielscher et al. [@HielscherEtAl:IDA14] showed that classification performance increases when features with temporal information are incorporated into the feature space. 
Instead of modeling the individual change of measurement values, our approach involves deriving multivariate change descriptors.
<!-- Hielscher et al. [@HielscherEtAl:IDA14] performed feature engineering on the set of measurements for each assessment collected over multiple wave.  -->
<!-- They showed that classification performance increases when features with temporal information are incorporated into the feature space.  -->
<!-- However, they did not consider modeling the change of subgroups of similar cohort participants over time as.  -->
<!-- TODO: checken ob das klar ist, nachdem die intro eingefügt wurde. -->

Patient evolution with clustering was studied by Siddiqui et al. [@SiddiquiEtAl:BIH14].
They proposed a method that predicts patient evolution from timestamped data by clustering them on similarity and predicting cluster movement in the multi-dimensional space. 
However, the patient data considered in [@SiddiquiEtAl:BIH14] are labeled at each moment.
 <!-- TODO: checken ob das klar ist, nachdem die intro eingefügt wurde. -->

<!-- Hypothesis-based studies on SHIP are numerous, -->
<!-- %(leading to hundreds of publications each year), -->
<!-- while mining studies are rare. For the outcome ``hepatic steatosis'', in [@NiemannEtal:ESWA14,HielscherEtAl:CBMS14] we concentrate on SHIP-2, while in [@HielscherEtAl:IDA14] we exploit the unlabeled recordings of the first two moments but do not model the evolution of the cohort members. -->
<!-- %For our method, we borrow the distance function and the dimensionality reduction step of [@HielscherEtAl:IDA14]. -->
<!-- %, but we first create an enhanced set of dimensions that describe the evolution of cohort members and of their clusters. -->


<!-- %for dimensionality reduction, but we cluster the participants at each moment and derive indices describing the evolution of these clusters. We show that these new variables improve classification quality. -->




<!-- **See Myras comment on labelling** -->
<!-- Papapetrou has much work on case b, conventional ts classification, and some work on case c (2019) -->
<!-- Christian has work on case a. Case a is typical stream classification but your stream is tiny. So, you should mention stream classification and then explain that you cannot use the advances, because you have too few timpoints and some of them without labels. -->

<!-- In this paper, we present a novel classification framework for detecting ADEs in complex Electronic health records (EHRs) by exploiting the temporality and sparsity of the underlying features. The proposed framework consists of three phases for transforming sparse and multi-variate time series features into a single-valued feature representation, which can then be used by any classifier. Moreover, we propose and evaluate three different strategies for leveraging feature sparsity by incorporating it into the new representation. -->
<!-- Contributions -->

<!-- Our work focuses on the use of EHR data for the application area of ADE detection, as it constitutes a serious and ubiquitous public health issue. Unfortunately, most approaches to ADE detection in EHRs do not take into account the temporality of clinical events, which is critical for this task, while they cannot effectively handle sparsity in the feature space since in a medical context values are not missing at random (MNAR) [40–42]. The technical contributions of this paper are, thus, summarized as follows: -->

<!--     a) -->

<!--     we propose a sparse symbolic representation for multi-variate feature spaces, with emphasis on temporal features of arbitrary lengths and high degree of sparsity, i.e., missing values. The proposed representation is based on the SAX time series summarization technique as well as on the concept of s-shapelets, which correspond to class-distinctive discrete event subsequences; -->
<!--     b) -->

<!--     we propose three strategies for dealing with such feature spaces: (1) length encoding or plain (which is an extension of Zhao et al. [32]), most-common encoding or mc, and left-right optimized encoding or lr; -->
<!--     c) -->

<!--     we provide an extensive experimental evaluation of the three strategies on 15 real datasets taken from the healthcare domain involving ADEs. Moreover, we study the utility of the chosen s-shapelets, as well as their consistency to medical findings in the context of ADE detection. -->

Our workflow combines labeled and unlabeled timestamped data from a longitudinal study to improve classification performance on skewed data. 
As the target variable, we study the multi-factorial disorder hepatic steatosis (fatty liver) on a sample of participants from the longitudinal population-based "Study of Health in Pomerania" (SHIP) [@Voelzke:SHIP11], recall Section&nbsp;\@ref(background-data-ship). 
For the SHIP cohort, the assessments (interviews, medical tests, etc.) were recorded in several _moments_ (SHIP-0, SHIP-1, etc.), that are ca. 5 years apart. 
Temporal information is often used when analyzing patient data in a hospital, but there the time granularity is different. 
For example, in an intensive care unit, timestamped data are collected at a fast pace, i.e., every minute or even every second. 
In contrast, the participants of a longitudinal epidemiological study are monitored for months or even years. 
Hence, measurements of the same assessment in an epidemiological dataset are few and possibly far apart. 
The large period between two consecutive recordings complicates applying methods designed for data that arrive with a higher frequency. 
For example, a participant may exhibit alcohol abuse or become pregnant, stop smoking and start again, take antibiotics that affect the liver, or experience other lifestyle changes that turn the medical recordings taken five years ago irrelevant for learning the participant's current health state. 
Another patient may have no lifestyle changes and no illnesses, so their past data reflect only aging. 
<!-- So, how much can we rely on historical data? -->

A further challenge is that the label is unavailable for several waves.
A reliable estimate of the fat accumulation in the liver was computed from magnetic resonance tomography images. 
In SHIP-0, MRT was unavailable. 
Instead, liver fat accumulation was derived from ultrasound -- a procedure with lower clinical accuracy. 
In SHIP-1, the calculation was omitted altogether. 
Consequently, for a given SHIP participant, the class label is available in SHIP-2, no label in SHIP-1, and a partially reliable indicator in SHIP-0. 
Since hepatic steatosis is a reversible disorder, label imputation -- using a growth model [@SingerWillelt03] -- is not possible; participant evolution must be learned with only one moment with labeled data.

<!-- %To summarize, the classification problem we are called to solve under exploitation of historical information is unconventional: the outcome (fatty liver in our study) is reversible, and is only recorded reliably in the third moment and less reliably in the first one. -->
<!-- %%not a conventional classification problem: each cohort participant should have a label at each wave, but this is not the case. The outcome (fatty liver in our study) is computed by a modern, reliable medical test that was not available in the past. Hence, all cohort participants are labeled at a specific moment, and none has a label at the past moments. Since the moments are very far apart, there is no reliable way of imputing labels to the old data: for no participant can we say that s/he was suffering under fatty liver 10 or 5 years ago. -->
<!-- %Hence, we have to exploit unlabeled historical data for a classification problem. -->

<!-- %Next, the set of variables recorded for the cohort participants changes from one moment to the next. This is the result of changes in the protocol of the epidemiological study: MRT of the liver became part of the protocol for the third wave; ultrasound of the liver was part of the protocol in the first wave and in the third one, but not in the second. Hence, we have to exploit historical data, where some variables are completely absent in some moment. -->
<!-- %%Moreover, the size of the cohort decreases with time. In a hospital setting, new patients arrive every moment, and learned models can be updated with fresh data. A cohort consists of a fixed set of participants; when some of them exit the cohort, they cannot be replaced. Hence, our classification problem involves a large first wave of participants, some of which are no more there in the next waves. Note that the class labels are available only for the participants that were present in the third wave. -->
<!-- %So, our research task is to exploit the incomplete historical data of cohort participants for a classification problem, for which we have labels at one (the most recent) moment, knowing that the (unknown) label of a given cohort participant at any past moment may have been different from her current, known label. -->

<!-- %a different task, though. Hospital records refer to patients, whilst a "cohort" of an epidemiological study consists of persons with and without the "outcome" (the disease). The learning goal is class separation with emphasis on finding the variables that contribute to separation. The cohort participants in "cross-sectional" epidemiological studies are so chosen, as to have classes of equal strength; participants of "population-based" studies are randomly selected, so that the prevalence of the disease (positive class) is as in the population under study. In a "longitudinal" study, cohort members are observed over several moments (in "waves"). For example, the first cohort of the longitudinal population-based study we use [@Voelzke:SHIP11] consists of three waves. \footnote{There is a second cohort, currently consisting of only one wave. That cohort is not relevant hereafter.} -->

<!-- %Data mining on longitudinal epidemiological data is much less studied. This is greatly due to the fact that epidemiological research is almost solely hypothesis-driven and thus disagrees fundamentally with the concept of data-driven knowledge discovery. -->
<!-- %%On the other hand, data miners often associate epidemiology with the study of the diffusion of diseases (epidemies). As pointed out by Marathe and Vulikanti in [@MaratheVulikanti:CACM2013] in their work on "Computational Epidemiology", informatics can greatly contribute to the work of epidemiology scholars on understanding and controling the spatiotemporal diffusion of disease through populations. However, epidemiological research encompasses much more topics, on which data mining can play a fundamental role. -->
<!-- %As stated by Preim et al. [@Preim:2014], epidemiology is "a scientific discipline that provides reliable knowledge for clinical medicine focusing on prevention, diagnosis and treatment of diseases." In this study, we propose a mining approach for the diagnosis of a disease (fatty liver, officially named "hepatic steatosis") from longitudinal population-based data. -->

<!-- %To exploit time in an epidemiological study, we must deal with a \emph{missing data} problem. In particular, the set of variables recorded at each moment, the "protocol", may change. Advances in medical research and technology, like the invention of magnetic resonance tomography (MRT), lead to the inclusion of new variables, while the recording of other variables is discontinued. In the epidemiological study we use, liver sonography was included in the first and third wave, liver MRT from the third wave on. Hence, even the sequence of recordings for the target variable may be incomplete, preventing insights on presence and progression of the disease. %at each moment. -->
<!-- %%, nor reconstruct the association of some other variable with the target \emph{over time}. -->
<!-- %%(e.g. if the sequence of sonography recordings or of blood pressure recordings is not complete). -->

We address these challenges as follows. 
First, we group study participants at each moment on similarity, thus building clusters of cohort members with similar recordings at one of the three moments. 
Then, we connect the clusters across time, thus capturing each cluster's transition from one study wave to the next. 
These transitions reflect the evolution of subpopulations, not individuals. 
Hence, next to the single labeled recording per cohort participant, we also exploit the earlier, unlabeled recordings, the description of the cluster they are assigned to, and information on how the clusters evolve. 
We show that this new, augmented dataset, combining labeled and unlabeled data on individuals and subpopulations, improves classification and delivers additional insights on some factors associated with hepatic steatosis.

## Problem Formulation {#evo-problem-formulation}

We now provide some basic symbols and essential functions for our classification problem, summarized in Table&nbsp;\@ref(tab:06-nomenclature).

(ref:06-nomenclature) **Symbols and essential functions.**

```{r 06-nomenclature, echo=FALSE}
`%>%` <- dplyr::`%>%`
eq <- ifelse(knitr::is_latex_output(), "\\ref{eq:heom-adjusted}", "\\@ref(eq:heom-adjusted)")
tibble::tribble(
  ~term, ~meaning,
  "$x$", "a study participant from cohort $X$",
  "$t$", "a study moment, one of $\\{1,\\ldots, T\\}$",
  "$f$", "a feature from the set of all features $F$",
  "$v(x,f,t)$", "the value of $x$ for feature $f$ at moment $t$",
	"$obs(x,F,t)$", "all measurements for $x$ at $t$, i.e., $\\{v(x,f,t)|\\forall f\\in{}F\\}$",
  "$label(x,t)$", "the class label of $x$ at moment $t$",
	"$Z(t)$", "all observations at $t$, i.e., $\\{obs(x,F,t)| \\forall x \\in X\\}$",
  "$c(x,t)$", "cluster membership of $x$ at $t$; if $x$ is an outlier at $t$, then $c(x,t)$ is NULL",
# %	$peers(x,t)$ & peers of $x$ at $t$, cf. Eq. \\ref{eq:peers} 
# %	$c(x,t) = \\emptyset$	&	if $c(x,t)=\\emptyset$, then $x$ is an outlier at $t$
	"$d(x,z,t)$", paste0("distance between $x$ and $z$ at $t$ (cf. Eq. ", eq, ")"),
	"$kNN(x,k,t)$", "the set of k nearest neighbors of $x$ at  $t$",
  "$centr(x,t)$", "centroid of $c(x,t)$"
  ) %>%
  purrr::set_names(c("Term", "Description")) %>%
  kableExtra::kbl(escape = FALSE, booktabs = TRUE, linesep = "",
                  caption = "(ref:06-nomenclature)") %>%
  kableExtra::kable_classic() %>%
  kableExtra::row_spec(0, bold = TRUE)
```

Our longitudinal study comprises data for a participant $x\in X$ for every feature $f\in F$ and every time point $t\in \{1,\ldots, T\}$ (also referred to as moment).
The (single) value of $x$ for feature $f$ at moment $t$ is denoted as $v(x,f,t)$; 
the set of all values for $x$ at $t$, i.e., $\{v(x,f,t)|\forall f\in{}F\}$, is denoted as $obs(x,F,t)$.
For some participant, $v(\cdot)$ is NULL, i.e., there may be missing values. 
Our goal is to to predict the class label of $x$ at moment $T$, i.e., $label(x,T)$ by using data from all observations in all previous moments $t\in\{1\ldots T-1\}$.
The class label of each participant is unavailable except for $t=T$. 
We model this prediction task as conventional classification problem. 
We aim to improve classification performance by expanding the feature space with change descriptors, the so-called _evolution features_, presented next.

## Evolution Features {#evo-concept}

We leverage latent temporal information of a longitudinal cohort study dataset by extracting informative features based on the individual change of participants and the transition of their respective clusters over time. 
For this purpose, we exploit the similarity among participants at each moment as a surrogate to the labels which are not available in the first two moments, assuming that similar participants evolve similarly.
<!-- damit ist gemeint: cluster quality like homogeneity -->
We call these new features _"evolution features"_.
Our approach is illustrated in Figure \@ref(fig:06-concept-workflow)&nbsp;(a). 
We monitor the individual change of participants across the study waves, trace the clusters' change separately, extract new features (from labeled _and_ unlabeled data) and augment the original data space with our new descriptors of change.
The complete classification workflow is depicted in Figure \@ref(fig:06-concept-workflow)&nbsp;(b). 

(ref:06-concept-workflow) **Concept of evolution feature extraction for classification performance improvement**. (a) Clustering of longitudinal cohort data and subsequent generation of evolution features from the change of individuals (red) and whole clusters (green). (b) Overview of the classification workflow. 

```{r 06-concept-workflow, echo=FALSE, fig.align='center', out.width="100%", fig.cap="(ref:06-concept-workflow)"}
knitr::include_graphics("figures/06-concept-workflow.png")
```

In the following, we describe the clustering of study participants (Section&nbsp;\@ref(evo-concept-clustering)), the generation of evolution features (Section&nbsp;\@ref(evo-concept-evo-features)), and our feature selection strategy to extract a subset of _informative_ features as input for classification (Section&nbsp;\@ref(evo-concept-feature-selection)), while dealing with class imbalance by undersampling the majority class.

<!-- \subsection{Clustering and Generation of Evolution Features} -->
### Clustering {#evo-concept-clustering}
For clustering, we prefer density-based clustering over partitional algorithms (like k-means) because our data contain extreme cases, the clusters may be arbitrarily shaped and of different sizes, and we cannot determine their number in advance.
At each moment $t$, we run the DBSCAN [@EsterEtAl:DBSCAN96] algorithm to cluster the set $Z(t)$ of recordings of all cohort members observed at $t$. 
For participant $x$, $v(x,f,t)$ denotes the value of $x$ for feature $f\in$ feature-set $F$ at $t$, and $obs(x,F,t)$ the set of all feature recordings for $x$ at $t$ (cf. notation in Table&nbsp;\@ref(tab:06-nomenclature)).

<!-- \paragraph{Distance function} -->
`r start_paragraph("Distance function.")` 
For the distance between participants $x,z$ at $t$, we use the _adjusted heterogeneous Euclidean overlap metric_ [@HielscherEtAl:IDA14; @Wilson97], which weights the difference between two values $x,z$ for feature $f$ by the feature's information gain $G(f)$, scaled to the largest observed value $G^*$, defined as:
\begin{equation}
d(x,z,t)=\sqrt{\sum_{f \in F} \left(\frac{G(f)}{G^*}\cdot \delta\left(v(x,f,t),v(z,f,t)\right)\right)^2}.
(\#eq:heom-adjusted)
\end{equation}
For continuous features, $\delta(a,b)$ is the min-max-scaled difference between the values $a,b$, i.e., $(a-b)/(\max(f)-\min(f))$. 
For nominal features, $\delta(a,b)$ is 0 if $a=b$, and 1 otherwise.

<!-- \paragraph{Specifying the DBSCAN parameters} -->
`r start_paragraph("DBSCAN Parameter setting.")`
DBSCAN relies on two parameters: the radius $eps$ of the neighborhood around a data point, and the minimum number $minPts$ of neighbors for a point to be a core point.
We use the "elbow" heuristic of Ester et al. [@EsterEtAl:DBSCAN96], which determines a suitable $eps$ value for a given $minPts$ value, illustrated in Figure&nbsp;\@ref(fig:06-k-dist-graph). 
More specifically, we define a parameter $k$ and compute for each $x\in{}Z(t)$ the distance k-dist$(x,k)$ to its kth nearest neighbor.
We sort these distances, draw the k-dist$(x,k)$ graph _g_, and span the line _l_ connecting the smallest k-dist() value to the largest one. 
Then, we set $eps$ to the k-dist value with the maximum distance between _g_ and _l_.

(ref:06-k-dist-graph) **Setting $eps$ based on the k-dist graph for a given $minPts$.** The k-dist graph _g_ depicts the sorted distances to the points' kth next neighbors. A suitable $eps_{opt}$ can be identified with the maximum distance between the k-dist and the line _l_ that connects the first and the last point of _g_. For DBSCAN clustering with $minPts$ = k, $eps_{opt}$, points with k-dist $\leq$ $eps_{opt}$ will become core points, else border or noise points.

```{r 06-k-dist-graph, echo=FALSE, fig.align='center', out.width=if(knitr::is_latex_output()){"6cm"}else{"70%"}, fig.cap="(ref:06-k-dist-graph)"}
knitr::include_graphics("figures/06-k-dist-graph.png")
```

<!-- \paragraph{Tracing evolution}  -->
### Constructing Evolution Features {#evo-concept-evo-features}
We extract information about the participants' evolution, distinguishing among those that evolve smoothly and those that switch among clusters. 
We transfer this information to evolution features, thus enriching the feature space with information from the unlabeled moments.
Table&nbsp;\@ref(tab:06-tab-evo-features) describes all evolution features.
They are divided into four categories: (A) features for each participant at each moment, (B) evolution features describing some aspect of change between study waves for an individual participant, (C) evolution features measuring changes between study waves concerning feature values for each participant, and (D) evolution features linked to a whole cluster.

For each cohort member $x$ and moment $t$, we record the cluster containing $x$ (feature 1 in Table&nbsp;\@ref(tab:06-tab-evo-features)), 
(2) the distance of $x$ to this cluster's centroid, 
(3) the fraction of positively labeled participants among the k nearest neighbors of $x$, 
(4) the (graph-based) cohesion [@TanDMbook] and (5) Silhouette coefficient [@TanDMbook] of $x$, and (6) the (graph-based) separation [@TanDMbook] of $x$ to cohort participants outside this cluster. 
We compute the difference of the cohesion, Silhouette, and separation values from $t$ to all later moments $\{t' \in T|t'>t\}$ (7-9), and also check how much the values of these metrics change as $x$ moves from $c(x,t)$ to $c(x,t')$ (10-12).
We record whether $x$ is an outlier, i.e., a DBSCAN noise point at some moment (13). 
For $t$ and $\{t' \in T|t'>t\}$, we compute the fraction of cohort members who are in the same cluster as $x$ in $t$ and $t'$ (14), and the fraction of common k nearest neighbors (15), and the change of the distance between $x$ and its centroid at $t$, from $t$ to $t'$ (16).
We further record changes in the sequence of values for a feature, including real (17), absolute (18), and relative (19) differences between the values at two moments.
We measure how a cluster shrinks/grows from $t$ to $t'$ (20), and how much its members move (on average) closer or far apart from their previous positions (21-23).

(ref:06-tab-evo-features) **Overview of extracted features.** The first group of features (A) comprises the cluster membership and aggregated distance information for each participant and each moment; feature group (B) is on changes in the participant's position (in the hyperspace) relative to the cluster and its closest neighbors; feature group (C) captures changes in the values of the participant's recordings; feature group (D) refers to changes in the clusters.

```{r 06-tab-evo-features, echo=FALSE}
`%>%` <- dplyr::`%>%`
eq <- ifelse(knitr::is_latex_output(), "\\ref{eq:heom-adjusted}", "\\@ref(eq:heom-adjusted)")
fix_ttt <- function(x) {
  if(knitr::is_latex_output()){
    stringr::str_replace_all(x, "`(.+?)`", "\\\\texttt\\{\\1\\}") %>%
      stringr::str_replace_all("\\[@(.+?)\\]", "\\\\cite\\{\\1\\}")
    } else {
      stringr::str_replace_all(x, "\\\\", "")
    }
}
tibble::tribble(
  ~no, ~term, ~meaning,
  "1", fix_ttt("`Cluster\\_t`"), "Cluster ID of $x$ at $t$",
  #
  "2", fix_ttt("`dist\\_To\\_Centroid\\_t`"), "Distance of $x$ to the centroid of cluster $c(x,t)$, denoted as $\\widehat{c(x,t)}$",
  #
  "3" , fix_ttt("`fraction\\_Of\\_POS\\_kNN\\_`$k$`\\_t`"), "Fraction of the k nearest neighbors of $x$ at $t$ from the positive class",
  #
  "4-6", fix_ttt("`a\\_t := a(x,t,c(x,t))`"), fix_ttt("$a$ is one of {cohesion, Silhouette, separation} [@TanDMbook]; cohesion$_t$ is the cohesion of $x$ at $t$ w.r.t. the members of $c(x,t)$ -- and similarly for silhouette and for separation"),
  #
  "7-9", fix_ttt("`a\\_Delta\\_t\\_t'`"), "Difference $a_{t} - a_{t'}$ for $a$ as above",
  #
  "10-12", fix_ttt("`a\\_Movement\\_t\\_t'`"), "Difference $a(x,t,c(x,t)) - a(x,t',c(x,t))$ for $a$ as above, referring to the same cluster $c(x,t)$ at two moments $t,t'$; at $t'$, $x\\in{}c(x,t')$, which does not need to be the same as $c(x,t)$",
  #
  "13", fix_ttt("`was\\_becomes\\_Outlier\\_t\\_t'`"), "Four-valued flag on whether $x$ was outlier in both $t, t'$, only in $t$, only in $t'$ or in neither$t, t'$",
  #
  "14", fix_ttt("`same\\_Cluster\\_t\\_t'`"), "$c(x,t)\\cap{}c(x,t')\\setminus\\{x\\}$: set of cohort members that are in the same cluster as $x$ in $t$ and in $t'$",
  #
  "15", fix_ttt("`same\\_kNN\\_`$k$`\\_t\\_t'`"), "$kNN(x,k,t)\\cap{}kNN(x,k,t')$, i.e., the set of cohort members who are among the k nearest neighbors of $x$ in both $t$ and in $t'$; they do not need to be in the same cluster as $x$",
  #
  "16", fix_ttt("`shift\\_To\\_Old\\_Centroid\\_t\\_t'`"), "Difference $d(x,\\widehat{c(x,t)},t')-(x,\\widehat{c(x,t)},t)$",
  #
  "17-19" , fix_ttt("`A\\_Diff\\_f\\_t\\_t'`"), "Difference between $v(x,f,t)$ and $v(x,f,t')$ for feature $f$, where $A$ is either real difference, absolute difference or relative difference to $v(x,f,t)$",
  #
  "20", fix_ttt("`smaller\\_Cluster\\_Fraction\\_t\\_t'`"), "Difference of the size of cluster $c$ at $t'$ and its size at $t$; $c$ is matched to the clusters of $t$ based on member overlap",
  #
  "21-23", fix_ttt("`movement\\_d\\_t\\_t'`"), paste0("Distance $d$ between the locations of the members of cluster $c$ at $t$ and their locations at $t'$, where $d$ is one of Euclidean distance, HEOM distance (cf. Eq. ", eq, "), Cosine similarity")
) %>%
  kableExtra::kbl(
    col.names = c("\\#", "Name", "Description"), 
    escape = FALSE, booktabs = TRUE, linesep = "",
    valign = "t",
    caption = "(ref:06-tab-evo-features)"
    ) %>%
  kableExtra::kable_classic() %>%
  # kableExtra::column_spec(2, extra_css = "vertical-align:top;") %>%
  kableExtra::column_spec(3, latex_column_spec = "p{8.5cm}") %>%
  kableExtra::pack_rows("(A) Features for participant $x$ at each moment", 1, 4, escape = FALSE) %>%
  kableExtra::pack_rows("(B) Evolution features linked to each participant $x$", 5, 10, escape = FALSE) %>%
  kableExtra::pack_rows("(C) Evolution features associated with the value of each original feature $f$ for participant $x$", 11, 11, escape = FALSE, latex_wrap_text = TRUE) %>%
  kableExtra::pack_rows("(D) Evolution features linked to a whole cluster $c$", 12, 13, escape = FALSE) %>%
  kableExtra::row_spec(0, bold = TRUE)
```

<!-- ### Undersampling {#evo-concept-undersampling} -->
<!-- For imbalanced data, feature selection and classification are often biased in favor of the majority class [@leevy2018survey].  -->
<!-- To avoid this problem, before the application of CFS we undersample the majority class and generate a balanced data set to select features informative with respect to all classes. -->
<!-- Let $X_{min}$ and $X_{max}$ be the set of participants belonging to the minority and majority class respectively. We iteratively select participants $x \in X_{max}$ at random and remove the participant from the set, setting $X_{max} = X_{max} \setminus{} x$ until $|X_{max}| = |X_{min}|$ holds true. Then, the feature selection algorithm is given the set $X_{min} \cup X_{max}$ as input.For some positive participatns, some features have extreme values \cite{NiemannEtal:ESWA14}. Oversampling would -->
<!-- % it is reported that some features show extreme values for some positive participants. -->
<!-- amplify the impact of such extrema. So, we rather undersample the negative class by random selection. % and removal. -->
<!-- %The positive class is underrepresented. -->
<!-- %In medical research for diagnostics, the data are often skewed, since the positive outcome is usually more rare than the healthy state. -->
<!-- %We undersample the negative class by random selection and removal of participants. -->
<!-- This also allows us to suppress heterogeneities in the negative class. -->

### Extending Correlation-Based Feature Selection to Include Evolution Features {#evo-concept-feature-selection}
For imbalanced data, feature selection and classification are often biased in favor of the majority class [@leevy2018survey]. 
Hence, before feature selection, we undersample the majority class and generate a balanced data set to select features informative with respect to all classes.
We use the feature selection method of Hielscher et al. [@HielscherEtAl:CBMS14] as follows: 
we invoke correlation-based feature selection [@Hall:CFS2000] (CFS), which builds up a feature set by iteratively inserting the feature that adds the most "merit" to it. 
The merit $M_F$ of a feature set $F$ is computed by calculating the information gain for each pair of features in $F$ (lower gain corresponds to low correlation and is thus preferred) and for each feature in $F$ towards the target variable (higher gain is better).
Continuous features are first discretized with the entropy-based method of Fayyad and Irani [@Fayyad:MDL93]. 
We discretize only for feature selection; for clustering and classification, we use the original values.

As shown in Figure&nbsp;\@ref(fig:06-concept-workflow), we perform feature selection twice. 
The first time, we consider only features recorded in all moments, which is essential for evolution tracing: we can only compute distances between objects in clusters located in the same topological space. 
After generating the evolution features, we build up the complete set of features, also considering those not recorded in each moment. 
On this set, we perform feature selection again to discard unpredictive (original or evolution) features. 
This final feature set is then used for classification. 

## Evaluation Setup {#evo-evaluation}
We evaluate our workflow with 10-fold cross-validation on four off-the-shelf classification algorithms: random forest [@Breiman:RandomForests2001] (RF), C4.5 decision tree [@Quinlan:C451993], Na&iuml;ve Bayes&nbsp;(NB), and k-nearest neighbor (kNN). 
First, we compare each algorithm's generalization performance when used alone (baseline variant) vs. when incorporated into our workflow (workflow-enhanced variant).
Further, we study the impact of different combinations of the three workflow components _undersampling_ (`U`), _feature selection_ (`F`), and _incorporation of generated evolution features_ (`G`). 
Sensitivity (true positive rate), specificity (true negative rate), and F-measure (harmonic mean of precision and recall) serve as evaluation measures.
As shown in Table&nbsp;\@ref(tab:06-workflow-variants), `Baseline` invokes only the classification algorithm; we use the classification algorithm which achieves the highest F-measure scores. 
The variant `U-G` performs undersampling and uses the generated evolution features for classification. 
Since we undersample only for feature selection and then build the classification models on the original dataset, so `U-G` is identical to `--G` and `U--` is identical to the `Baseline` variant, so we omit to list `U-G` and `U--` explicitly.

The main parameter is $k$ which is the number of neighbors of a data point: we set $minPts$ = $k$ and use $k$ to derive the values of the DBSCAN parameter $eps$ (cf. Section&nbsp;\@ref(evo-concept-clustering)) and of the parameters for the features `same_kNN_`$k$`_t_1_t_2` and `fraction_Of_POS_kNN_`$k$`_t` (cf. Table&nbsp;\@ref(tab:06-tab-evo-features)). 
Further, the number of nearest neighbors for the k-NN classification algorithm is also set to $k$. 
We vary $k$ to measure its impact on classification performance. 

Following the findings in Chapters&nbsp;\@ref(imm) and&nbsp;\@ref(sdclu) on the differences between female and male participants with respect to the outcome, we run the experiments on the whole dataset (`PartitionAll`) and on the partitions of female (`PartitionF`) and male (`PartitionM`) participants. 
Finally, we list the most important features found in `PartitionAll` and its two subsets.
<!-- Due to space limits, we present only the experiments on the complete dataset \footnote{The experiments on the two partitions are under \url{http://bit.ly/1Dd82KE}.}. -->
<!-- %Following the findings of \cite{NiemannEtal:ESWA14,HielscherEtAl:CBMS14,HielscherEtAl:IDA14} on the differences between female and male participants with respect to the outcome, we also run our workflow on the partitions of female and male participants; these results are in a supplement  \footnote{ \url{http://www.kmd.ovgu.de/xyz}}. -->
<!-- %which consider a subset of \subcohort, -->
<!-- %we split the dataset into \partitionF (462 female participants, 19\% positive) and \partitionM (426 male participants, 35\% positive) and learn on each partition\footnote{Due to lack of space, we elaborate on results for \partitionF and \partitionM in an external appendix which is accessible at \url{http://www.kmd.ovgu.de/xyz}.}, as in \cite{HielscherEtAl:CBMS14,NiemannEtal:ESWA14}. -->
<!-- %%We experimented with the complete dataset and with the partitions of female and male participants -->
<!-- In subsection \ref{subsec:findings}, we report on important features for the complete dataset \emph{and} for the two partitions. -->

<!-- %We run our experiments on the complete dataset \partitionA and on the subsets of female and male participants, \partitionF and \PartitionM. We then study the impact of the workflow components on sensitivity, accuracy and F-measure. We report only on \PartitionA, due to lack of space\footnote{\textcolor[rgb]{0,0,1}{The description of the results as well as the corresponding figures for the two subsets \partitionF and \partitionM can be accessed at \url{http://www.kmd.ovgu.de/xyz}}}. Finally, we list the most important features found in \partitionA and its two subsets. -->

(ref:06-workflow-variants) **Workflow variants.** `UFG` is the complete workflow.

```{r 06-workflow-variants, echo=FALSE}
`%>%` <- dplyr::`%>%`
yes <- "&#x2713;"
no <- "&#x2717;"
if(knitr::is_latex_output()) {
  yes <- "\\ding{51}"
  no <- "\\ding{55}"
}
tibble::tribble(
  ~components, ~us, ~fs, ~evo,
  "UFG", yes, yes, yes,
  "UF-", yes, yes, no,
  "-FG", no, yes, yes,
  "-F-", no, yes, no,
  ifelse(knitr::is_latex_output(), "-{}-G", "\\-\\-G"), no, no, yes,
  "Baseline", no, no, no,
) %>%
  purrr::set_names(c("Workflow components", "Under-sampling", "Feature selection", "Evolution features")) %>%
  kableExtra::kbl(escape = FALSE, booktabs = TRUE, linesep = "",
                  align = "cccc",
                  caption = "(ref:06-workflow-variants)") %>%
  kableExtra::kable_classic() %>%
  kableExtra::row_spec(0, bold = TRUE) %>%
  kableExtra::column_spec(column = 1:4, width = "2.5cm") %>%
  kableExtra::column_spec(column = 1, width = "2.5cm", monospace = TRUE) 
```

## Results {#evo-results}

Figure&nbsp;\@ref(fig:06-perf-wf-classifiers) shows sensitivity (left), specificity (center), and F-measure (right) for the simple classifiers (gray curves) and their workflow-enhanced counterparts (same line style, colored) for different k.

(ref:06-perf-wf-classifiers) **Comparison of classification performance between workflow and baseline.** Sensitivity (left), specificity (center) and F-measure scores (right) of different classifiers when varying the number k of neighbors to a cohort member which impacts the clustering result. For each classifier, two performance curves are shown: a colored one for the workflow-enhanced version and a gray one for the baseline counterpart. Higher values are better for all measures. The figure is adapted from [@Niemann:CBMS2015].

```{r 06-perf-wf-classifiers, echo=FALSE, fig.align='center', out.width="100%", fig.cap="(ref:06-perf-wf-classifiers)"}
knitr::include_graphics("figures/06-perf-wf-classifiers-palatino.png")
```

<!-- We consider high sensitivity and F-measure as more important than specificity towards the majority class. -->
<!-- %A good classifier has high sensitivity and F-measure, and good specificity. %is not be misled by the majority class. -->
Overall, each workflow-enhanced variant outperforms its simple counterpart with respect to sensitivity and F-measure, and outperforms or performs slightly worse in specificity.
The workflow-enhanced Naive Bayes performs best concerning sensitivity for any k and best for k = 31.
Decision trees exhibit the highest F-measure, with improvements on sensitivity and F-measure compared to its simple variant, albeit specificity being slightly worse; improvements are less for large k. 
Random Forests benefit the most from our workflow, with an absolute improvement in F-measure of over 30% (green vs. gray "+" curves in the right part of Figure&nbsp;\@ref(fig:06-perf-wf-classifiers)).
One explanation for the relatively low sensitivity of the simple RF variant is the large number of trees (100) learned on data samples containing very few positive examples: RF could have been trapped by the many majority class examples. 
This result is consistent with the specificity curve (almost straight line around 95%) of simple RF, while the F-measure is slightly above 40%. 
Our workflow improves RF sensitivity (63%) and F-measure (65%), while specificity remains high (90%).
Overall, the impact of k on the three measures is limited for all algorithms except for the workflow-enhanced and the baseline k-NN, which is naturally affected stronger by the value of k than any other algorithm. 
Therefore, the workflow-enhanced variants outperform their simple counterparts in terms of sensitivity and F-measure. For some algorithms, our workflow prevents overfitting to the negative class.

The results of the workflow component-specific results in Figure&nbsp;\@ref(fig:06-perf-wf-components) show that our complete workflow `UFG` and the variants `UF-` and `--G` outperform the other variants in sensitivity and F-measure. 
The variants `-F-` and `-FG` perform well only regarding specificity, suggesting that feature selection may not be beneficial without undersampling for datasets with class imbalance.

(ref:06-perf-wf-components) **Comparison of classification performance for workflow components.** Sensitivity (left), specificity (center) and F-measure scores (right) for each workflow variant and the baseline using decision tree for learning. The figure is adapted from [@Niemann:CBMS2015].

```{r 06-perf-wf-components, echo=FALSE, fig.align='center', out.width="100%", fig.cap="(ref:06-perf-wf-components)"}
knitr::include_graphics("figures/06-perf-wf-components-palatino.png")
```

<!-- `r start_paragraph("Important features.")`  -->
## Identification of Important Evolution Features {#evo-important-features}
The performance of the workflow variants, which include feature selection, indicates that a small number of features is sufficient for class separation. 
Hereafter, we report on the evolution features selected for classification and appearing among the top 15 features according to information gain for each partition; we term these features "important". 

Figure&nbsp;\@ref(fig:06-imp-features-all) shows that for `PartitionAll` 3 out of these 15 features are generated evolution features. 
The boxplots (a) and (c) in Figure&nbsp;\@ref(fig:06-imp-features-all) refer to differences between values recorded in two moments. 
The feature `separationDelta_g_1_2` measures the difference in cluster separation for each participant based on the cluster assignment in moment 1 and 2, and corresponds to entry #9 in Table&nbsp;\@ref(tab:06-tab-evo-features). 
Participants belonging to the positive class exhibit a higher median in `separationDelta_g_1_2` than participants without the disorder, indicating that clusters harboring mostly positive participants cover larger, more sparse areas. 
The feature `relative_Difference_som_huef_g_0_1` (#19) quantifies the difference in a participant's hip circumference between SHIP-0 and SHIP-1, relative to the value in SHIP-0. 
On average, study participants from both classes lose weight when they grow older. Negative participants reduce more weight than positive participants (cf. Figure \@ref(fig:06-imp-features-all)&nbsp;(c)), which generally reflects differences in lifestyles.
The mosaic chart in Figure \@ref(fig:06-imp-features-all)&nbsp;(b) for feature `fraction_of_Positives_kNN_1_g_2` (#3) indicates that the "nearest neighbor" of a fatty liver participant is also more likely to exhibit the disorder than it is for a participant without fatty liver. 

(ref:06-imp-features-all) **Selected evolution features with the highest contribution to class separation for `PartitionAll`.** (a) Difference in cluster separation between SHIP-1 and SHIP-2. (b) Whether (=1) or not (=0) the nearest neighbor is of the positive class in SHIP-2. (c) Relative difference in hip circumference between SHIP-0 and SHIP-1.

```{r 06-imp-features-all, echo=FALSE, fig.align='center', out.width="100%", fig.cap="(ref:06-imp-features-all)"}
knitr::include_graphics("figures/06-imp-features-all.png")
```

For `PartitionF`, 5 out of the top 15 features are evolution features, cf. Figure&nbsp;\@ref(fig:06-imp-features-women). 
Compared with female participants without the disorder, female subjects with fatty liver exhibit a larger distance to the centroid of their cluster in SHIP-1 (#2), a lower silhouette coefficient in SHIP-1 (#5), a higher difference in waist circumference between SHIP-0 and SHIP-2 (#19), and a lower relative difference in serum triglycerides concentration between SHIP-0 and SHIP-1 (#19). 

(ref:06-imp-features-women) **Selected evolution features with the highest contribution to class separation for `PartitionF`.** (a) Distance to cluster centroid in SHIP-1. (b) Silhouette coefficient in SHIP-1. (c) Relative difference in waist circumference between SHIP-0 and SHIP-2. (d) Absolute value of relative difference in serum triglycerides between SHIP-0 and SHIP-1.

```{r 06-imp-features-women, echo=FALSE, fig.align='center', out.width="100%", fig.cap="(ref:06-imp-features-women)"}
knitr::include_graphics("figures/06-imp-features-women.png")
```

For `PartitionM`, 2 out of the top 15 features are evolution features (Figure&nbsp;\@ref(fig:06-imp-features-men)), including the relative difference in waist circumference between SHIP-1 and SHIP-2 (#19) and difference in cluster separation between SHIP-0 and SHIP-1 (#6). 
For both features, participants exhibiting the disorder have greater values. 

(ref:06-imp-features-men) **Selected evolution features with the highest contribution to class separation for `PartitionM`.** (a) Relative difference in waist circumference between SHIP-1 and SHIP-2. (b) Difference in cluster separation between SHIP-0 and SHIP-1.

```{r 06-imp-features-men, echo=FALSE, fig.align='center', out.width="100%", fig.cap="(ref:06-imp-features-men)"}
knitr::include_graphics("figures/06-imp-features-men.png")
```

## Conclusion {#evo-conclusion}

We have extended our set of methods for static medical data presented in Part&nbsp;`r if(knitr::is_latex_output()){"\\ref{part-subpopulation-discovery-in-high-dimensional-data}"}else{"I"}` by proposing a workflow for the classification of longitudinal cohort study data that exploits inherent temporal information by clustering the cohort participants at each moment, linking the clusters, and tracing participant evolution over the study's moments. 
We extract _evolution features_ from the clusters and their transitions, which are added to the feature space and subsequently used for classification. 
The workflow improves the generalization performance with respect to sensitivity and F-measure scores. 
The generated evolution features contribute to this improvement, even when used alone and without undersampling the skewed data. 
We have shown that the change of somatographic variables' values and cluster quality indices over time are predictive.

A limitation concerns the assessment of a feature's importance using information gain. 
The additional merit a feature has towards model predictions cannot be assessed being decoupled from the actual model. 
Furthermore, models may incorporate complex feature interactions that are not captured or subpopulation-specific differences in feature importance. 
Part&nbsp;`r if(knitr::is_latex_output()){"\\ref{part-post-mining-for-interpretation}"}else{"III"}` addresses _post-hoc model interpretation_, which includes more sophisticated approaches of measuring a feature's attribution to a model.
